<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lodging Simulator: C:/Users/YJU/Documents/GitHub/LodgingSimulator/Assets/Packages/ZLinq.1.4.0 디렉토리 참조</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lodging Simulator<span id="projectnumber">&#160;0.0.9</span>
   </div>
   <div id="projectbrief">Lodging Simulator Topdown Tycoon</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="검색" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_3434b0f81afe74e216ba227be80e6f9e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ZLinq.1.4.0 디렉토리 참조</div></div>
</div><!--header-->
<div class="contents">

<p><p>/// Gets the namespace where the generated LINQ implementations will be placed. /// If empty, the implementations will be generated in the global namespace. /// </p>
 
<a href="#details">더 자세히 ...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">상세한 설명</h2>
<p>/// Gets the namespace where the generated LINQ implementations will be placed. /// If empty, the implementations will be generated in the global namespace. /// </p>
<p>Zero allocation LINQ with LINQ to Span, LINQ to SIMD, and LINQ to Tree (FileSystem, JSON, GameObject, etc.) for all .NET platforms(netstandard2.0, 2.1, net8, net9) and <a class="el" href="namespace_unity.html">Unity</a>, Godot.</p>
<p><img src="img/benchmarkhead.jpg" alt="" class="inline"/></p>
<p>Unlike regular LINQ, ZLinq doesn't increase allocations when adding more method chains, and it also has higher basic performance. You can check various benchmark patterns at <a href="https://github.com/Cysharp/ZLinq/actions/runs/14569138271">GitHub Actions/Benchmark</a>. ZLinq shows high performance in almost all patterns, with some benchmarks showing overwhelming differences.</p>
<p>As a bonus, LINQ operators and optimizations equivalent to .NET 10 can be used in .NET Framework 4.8 (netstandard2.0) and <a class="el" href="namespace_unity.html">Unity</a> (netstandard2.1).</p>
<div class="fragment"><div class="line">dotnet add package ZLinq</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using </span>ZLinq;</div>
<div class="line"> </div>
<div class="line">var seq = source</div>
<div class="line">    .AsValueEnumerable() <span class="comment">// only add this line</span></div>
<div class="line">    .Where(x =&gt; x % 2 == 0)</div>
<div class="line">    .Select(x =&gt; x * 3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">foreach</span> (var item <span class="keywordflow">in</span> seq) { }</div>
</div><!-- fragment --><ul>
<li><b>99% compatibility</b> with .NET 10's LINQ (including new <code>Shuffle</code>, <code>RightJoin</code>, <code>LeftJoin</code> operators)</li>
<li><b>Zero allocation</b> for method chains through struct-based Enumerable via <code>ValueEnumerable</code></li>
<li><b>LINQ to Span</b> to full support LINQ operations on <code>Span&lt;T&gt;</code> using .NET 9/C# 13's <code>allows ref struct</code></li>
<li><b>LINQ to Tree</b> to extend tree-structured objects (built-in support for FileSystem, JSON, GameObject)</li>
<li><b>LINQ to SIMD</b> to automatic application of SIMD where possible and customizable arbitrary operations</li>
<li>Optional <b>Drop-in replacement</b> Source Generator to automatically accelerate all LINQ methods</li>
</ul>
<p>In ZLinq, we have proven high compatibility and performance by running <a href="https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests">dotnet/runtime's System.Linq.Tests</a> as a drop-in replacement, passing 9000 tests.</p>
<p><img src="img/testrun.png" alt="" class="inline"/></p>
<p>Previously, value type-based LINQ implementations were often experimental, but ZLinq fully implements all methods to completely replace standard LINQ in production use, delivering high performance suitable even for demanding applications like games. The performance aspects are based on my experience with previous LINQ implementations (<a href="https://github.com/neuecc/linq.js/">linq.js</a>, <a href="https://github.com/Cysharp/SimdLinq/">SimdLinq</a>, <a href="https://github.com/neuecc/UniRx">UniRx</a>, <a href="https://github.com/Cysharp/R3">R3</a>), zero-allocation implementations (<a href="https://github.com/Cysharp/ZString">ZString</a>, <a href="https://github.com/Cysharp/ZLogger">ZLogger</a>), and high-performance serializers (<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/">MessagePack-CSharp</a>, <a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>).</p>
<p>ZLinq achieves zero-allocation LINQ implementation using the following structs and interfaces.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> readonly <span class="keyword">ref struct</span> ValueEnumerable&lt;TEnumerator, T&gt;(TEnumerator enumerator)</div>
<div class="line">    where TEnumerator : struct, IValueEnumerator&lt;T&gt;, allows ref struct</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> readonly TEnumerator Enumerator = enumerator;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">interface </span>IValueEnumerator&lt;T&gt; : IDisposable</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> TryGetNext(out T current); <span class="comment">// as MoveNext + Current</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optimization helper</span></div>
<div class="line">    <span class="keywordtype">bool</span> TryGetNonEnumeratedCount(out <span class="keywordtype">int</span> count);</div>
<div class="line">    <span class="keywordtype">bool</span> TryGetSpan(out ReadOnlySpan&lt;T&gt; span);</div>
<div class="line">    <span class="keywordtype">bool</span> TryCopyTo(Span&lt;T&gt; destination, Index offset);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Besides changing to a struct-based approach, we've integrated MoveNext and Current to reduce the number of iterator calls. Also, some operators don't need to hold Current, which allows minimizing the struct size. Additionally, being struct-based, we efficiently separate internal state by copying the Enumerator instead of using GetEnumerator. With .NET 9/C# 13 or later, <code>allows ref struct</code> enables natural integration of <code>Span&lt;T&gt;</code> into LINQ.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ValueEnumerable&lt;Where&lt;TEnumerator, TSource&gt;, TSource&gt; Where&lt;TEnumerator, TSource&gt;(<span class="keyword">this</span> ValueEnumerable&lt;TEnumerator, TSource&gt; source, Func&lt;TSource, Boolean&gt; predicate)</div>
<div class="line">    where TEnumerator : <span class="keyword">struct</span>, IValueEnumerator&lt;TSource&gt;, allows <span class="keyword">ref struct</span></div>
<div class="line">````</div>
<div class="line"> </div>
<div class="line">Operators have this method signature. C# cannot infer types from generic constraints([dotnet/csharplang#6930](https:<span class="comment">//github.com/dotnet/csharplang/discussions/6930)). Therefore, the traditional Struct LINQ approach required implementing all operator combinations as instance methods, resulting in [100,000+ methods and massive assembly sizes](https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/). However, in ZLinq, we&#39;ve successfully avoided all the boilerplate method implementations by devising an approach that properly conveys types to C# compiler.</span></div>
<div class="line"> </div>
<div class="line">Additionally, `TryGetNonEnumeratedCount(out int count)`, `TryGetSpan(out ReadOnlySpan&lt;T&gt; span)`, and `TryCopyTo(Span&lt;T&gt; destination, Index offset)` defined in the interface itself enable flexible optimizations. To minimize assembly size, we&#39;ve designed the library to achieve maximum optimization with minimal method additions. For example, `TryCopyTo` works efficiently with methods like `ToArray` when combined with `TryGetNonEnumeratedCount`. However, it also allows copying to smaller-sized destinations. By combining this with Index, we can optimize `First`, `Last`, and `ElementAt` using just `TryCopyTo` by passing a single-element Span along with an Index.</div>
<div class="line"> </div>
<div class="line">Getting Started</div>
<div class="line">---</div>
<div class="line">You can install package from [NuGet/ZLinq](https:<span class="comment">//www.nuget.org/packages/ZLinq). For Unity usage, refer to the [Unity section](#unity). For Godot usage, refer to the [Godot section](#godot).</span></div>
</div><!-- fragment --><p> bash dotnet add package ZLinq </p><div class="fragment"><div class="line">Use `using ZLinq;` and call `AsValueEnumerable()` on any iterable type to use ZLinq&#39;s zero-allocation LINQ.</div>
</div><!-- fragment --><p> csharp using ZLinq;</p>
<p>var source = new int[] { 1, 2, 3, 4, 5 };</p>
<p>// Call AsValueEnumerable to apply ZLinq var seq1 = source.AsValueEnumerable().Where(x =&gt; x % 2 == 0);</p>
<p>// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct) Span&lt;int&gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 }; var seq2 = span.AsValueEnumerable().Select(x =&gt; x * x); </p><div class="fragment"><div class="line">Even if it&#39;s netstandard 2.0 or below .NET 10, all operators up to .NET 10 are available.</div>
<div class="line"> </div>
<div class="line">You can method chain and foreach like regular LINQ, but there are some limitations. Please see [Difference and Limitation](#difference-and-limitation) for details. ZLinq has drop-in replacements that apply ZLinq without needing to call `AsValueEnumerable()`. For more information, see [Drop-in replacement](#drop-in-replacement). Detailed information about [LINQ to Tree](#linq-to-tree) for LINQ-ifying tree structures (FileSystems and JSON) and [LINQ to SIMD](#linq-to-simd) for expanding SIMD application range can be found in their respective sections.</div>
<div class="line"> </div>
<div class="line">Additional Operators</div>
<div class="line">---</div>
<div class="line">In ZLinq, we prioritize compatibility, so we try to minimize adding custom operators. However, the following methods have been added to enable efficient processing with zero allocation:</div>
<div class="line"> </div>
<div class="line">### `AsValueEnumerable()`</div>
<div class="line"> </div>
<div class="line">Converts existing collections to a type that can be chained with ZLinq. Any `IEnumerable&lt;T&gt;` can be converted, but for the following types, conversion is done with zero allocation without `IEnumerable&lt;T&gt;.GetEnumerator()` allocation. Standard supported types are `T[]`, `List&lt;T&gt;`, `ArraySegment&lt;T&gt;`, `Memory&lt;T&gt;`, `ReadOnlyMemory&lt;T&gt;`, `ReadOnlySequence&lt;T&gt;`, `Dictionary&lt;TKey, TValue&gt;`, `Queue&lt;T&gt;`, `Stack&lt;T&gt;`, `LinkedList&lt;T&gt;`, `HashSet&lt;T&gt;`, `ImmutableArray&lt;T&gt;`, `Span&lt;T&gt;`, `ReadOnlySpan&lt;T&gt;`. However, conversion from `ImmutableArray&lt;T&gt;` requires `.NET 8` or higher, and conversion from `Span&lt;T&gt;`, `ReadOnlySpan&lt;T&gt;` requires `.NET 9` or higher.</div>
<div class="line"> </div>
<div class="line">### `ValueEnumerable.Range()`, `ValueEnumerable.Repeat()`, `ValueEnumerable.Empty()`</div>
<div class="line"> </div>
<div class="line">`ValueEnumerable.Range` operates more efficiently when handling with `ZLinq` than `Enumerable.Range().AsValueEnumerable()`. The same applies to `Repeat` and `Empty`.</div>
<div class="line"> </div>
<div class="line">### `Average() : where INumber&lt;T&gt;`, `Sum() : where INumber&lt;T&gt;`</div>
<div class="line"> </div>
<div class="line">System.Linq&#39;s `Average` and `Sum` are limited to certain primitive types, but ZLinq extends them to all `INumber&lt;T&gt;` types. In `.NET 8` or higher, where constraints are included, but for others (netstandard2.0, 2.1), runtime errors will occur when called with non-primitive target types.</div>
<div class="line"> </div>
<div class="line">### `SumUnchecked()`</div>
<div class="line"> </div>
<div class="line">`Sum` is `checked`, but checking for overflow during SIMD execution creates performance overhead. `SumUnchecked` skips overflow checking to achieve maximum SIMD aggregation performance. Note that this requires `.NET 8` or higher, and SIMD-supported types are `sbyte`, `short`, `int`, `long`, `byte`, `ushort`, `uint`, `ulong`, `double`, and the source must be able to get a Span (`TryGetSpan` returns true).</div>
<div class="line"> </div>
<div class="line">### `AggregateBy`, `CountBy` constraints</div>
<div class="line"> </div>
<div class="line">.NET 9 `AggregateBy` and `CountBy` has `TKey : notnull` constraints. However, this is due to internal implementation considerations, and it lacks consistency with traditional operators such as Lookup and Join. Therefore, in ZLinq, the notnull constraint was removed.</div>
<div class="line"> </div>
<div class="line">### `int CopyTo(Span&lt;T&gt; destination)`, `void CopyTo(List&lt;T&gt; list)`</div>
<div class="line"> </div>
<div class="line">`CopyTo` can be used to avoid allocation of the return collection unlike `ToArray` or `ToList`. `int CopyTo(Span&lt;T&gt; destination)` allows the destination to be smaller than the source, returning the number of elements copied. `void CopyTo(List&lt;T&gt; list)` clears the list and then fills it with elements from the source, so the destination size is list.Count.</div>
<div class="line"> </div>
<div class="line">### `PooledArray&lt;TSource&gt; ToArrayPool()`</div>
<div class="line"> </div>
<div class="line">The returned array is rented from `ArrayPool&lt;TSource&gt;.Shared`. `PooledArray&lt;TSource&gt;` defines `.Span`, `.Memory`, `.AsEnumerable()` and other methods. These allow you to pass a `ValueEnumerable` to another method while minimizing allocations. Additionally, through `.AsValueEnumerable()`, you can call `ZLinq` methods, which is useful for temporarily materializing computationally expensive operations. Being `IDisposable`, you can return the borrowed array to `ArrayPool&lt;TSource&gt;.Shared` using the `using` statement.</div>
</div><!-- fragment --><p> csharp using var array = ValueEnumerable.Range(1, 1000).ToArrayPool();</p>
<p>var span = array.Span; var memory = array.Memory; var arraySegment = array.ArraySegment; var enumerable = array.AsEnumerable(); var valueEnumerable = array.AsValueEnumerable(); </p><div class="fragment"><div class="line">For performance reasons to reduce allocations, `PooledArray&lt;TSource&gt;` is a `struct`. This creates a risk of returning the same array multiple times due to boxing or copying. Also, ArrayPool is not suitable for long-term array storage. It is recommended to simply use `ToArrayPool()` with `using` and keep the lifetime short.</div>
<div class="line"> </div>
<div class="line">If you absolutely need the raw internal array, you can `Deconstruct` it to `(T[] Array, int Size)`. After deconstructing, ownership is considered transferred, and all methods of `PooledArray&lt;TSource&gt;` become unavailable.</div>
<div class="line"> </div>
<div class="line">### `JoinToString(char|string seperator)`</div>
<div class="line"> </div>
<div class="line">Since `ZLinq` is not `IEnumerable&lt;T&gt;`, it cannot be passed to `String.Join`. `JoinToString` provides the same functionality as `String.Join`, returning a string joined with the separator.</div>
<div class="line"> </div>
<div class="line">Difference and Limitation</div>
<div class="line">---</div>
<div class="line">For .NET 9 and above, `ValueEnumerable&lt;T&gt;` is a `ref struct` and cannot be converted to `IEnumerable&lt;T&gt;`. To ensure compatibility when upgrading, `AsEnumerable` is not provided by default even for versions prior to .NET 9.</div>
<div class="line"> </div>
<div class="line">Since `ValueEnumerable&lt;T&gt;` is not an `IEnumerable&lt;T&gt;`, it cannot be passed to methods that require `IEnumerable&lt;T&gt;`. It&#39;s also difficult to pass it to other methods due to the complex type signatures required by generics (implementation is explained in the [Custom Extensions](#custom-extensions) section). Using `ToArray()` is one solution, but this can cause unnecessary allocations in some cases. For temporary use, you can call `ToArrayPool` to pass to methods that require `IEnumerable&lt;T&gt;` without allocations. However, be careful that this `IEnumerable&lt;T&gt;` will be returned within the using scope, so you must ensure it doesn&#39;t leak outside the scope (storing it in a field is not allowed).</div>
<div class="line"> </div>
<div class="line">`String.Join` has overloads for both `IEnumerable&lt;string&gt;` and `params object[]`. Passing `ValueEnumerable&lt;T&gt;` directly will select the `object[]` overload, which may not give the desired result. In this case, use the `JoinToString` operator instead.</div>
<div class="line"> </div>
<div class="line">`ValueEnumerable&lt;T&gt;` is a struct, and its size increases slightly with each method chain. With many chained methods, copy costs can become significant. When iterating over small collections, these copy costs can outweigh the benefits, causing performance to be worse than standard LINQ. However, this is only an issue with extremely long method chains and small iteration counts, so it&#39;s rarely a practical concern.</div>
<div class="line"> </div>
<div class="line">Each chain operation returns a different type, so you cannot reassign to the same variable. For example, code that continuously reassigns `Concat` in a for loop cannot be implemented.</div>
<div class="line"> </div>
<div class="line">In .NET 8 and above, the `Sum` and `Average` methods for `double` use SIMD processing, which performs parallel processing based on SIMD width. This results in calculation errors that differ from normal ones due to the different order of addition.</div>
<div class="line"> </div>
<div class="line">Drop-in replacement</div>
<div class="line">---</div>
<div class="line">When introducing `ZLinq.DropInGenerator`, you can automatically use ZLinq for all LINQ methods without calling `AsValueEnumerable()`.</div>
</div><!-- fragment --><p> bash dotnet add package ZLinq.DropInGenerator </p><div class="fragment"><div class="line">![](img/dropin.jpg)</div>
<div class="line"> </div>
<div class="line">It works by using a Source Generator to add extension methods for each type that take priority, making `ZLinq` methods be selected instead of System.Linq when the same name and arguments are used. </div>
<div class="line">After installing the package, you need to configure it with an assembly attribute.</div>
</div><!-- fragment --><p> csharp [assembly: ZLinq.ZLinqDropInAttribute("ZLinq", ZLinq.DropInGenerateTypes.Array)] </p><div class="fragment"><div class="line">`generateNamespace` is the namespace for the generated code, and `DropInGenerateTypes` selects the target types. </div>
<div class="line">`DropInGenerateTypes` allows you to choose from `Array`, `Span` (Span/ReadOnlySpan), `Memory` (Memory/ReadOnlyMemory), `List`, and `Enumerable` (IEnumerable). </div>
<div class="line">These are Flags, so you can combine them, such as `DropInGenerateTypes.Array | DropInGenerateTypes.Span`. </div>
<div class="line">There are also predefined combinations: `Collection = Array | Span | Memory | List` and `Everything = Array | Span | Memory | List | Enumerable`.</div>
<div class="line"> </div>
<div class="line">When using `DropInGenerateTypes.Enumerable`, which generates extension methods for `IEnumerable&lt;T&gt;`, you need to make `generateNamespace` global as a namespace priority. </div>
<div class="line">For example:</div>
</div><!-- fragment --><p> csharp [assembly: ZLinq.ZLinqDropInAttribute("", ZLinq.DropInGenerateTypes.Everything)] </p><div class="fragment"><div class="line">This is the most aggressive configuration, causing all LINQ methods to be processed by ZLinq, and making it impossible to use normal LINQ methods (if Enumerable is not included, you can call AsEnumerable() to execute with System.Linq).</div>
<div class="line"> </div>
<div class="line">It&#39;s better to use application&#39;s default namespace rather than globally, as this allows you to switch between normal LINQ using namespaces. This approach is recommended when you need to target `Enumerable`.</div>
</div><!-- fragment --><p> csharp using ZLinq;</p>
<p>[assembly: ZLinqDropInAttribute("MyApp", DropInGenerateTypes.Everything)]</p>
<p>// namespace under MyApp namespace MyApp.Foo { public class Bar { public static void Foo(IEnumerable&lt;int&gt; source) { // ZLinq ValueEnumerable&lt;T&gt; var seq = source.Select(x =&gt; x * 2).Shuffle(); using var e = seq.Enumerator; while (e.TryGetNext(out var current)) { Console.WriteLine(current); } } } }</p>
<p>// not under MyApp namespace namespace NotMyApp { public class Baz { public static void Foo(IEnumerable&lt;int&gt; source) { // IEnumerable&lt;T&gt; var seq = source.Select(x =&gt; x * 2); // .Shuffle(); using var e = seq.GetEnumerator(); while (e.MoveNext()) { Console.WriteLine(e.Current); } } } } </p><div class="fragment"><div class="line">ZLinq is powerful and in many cases it performs better than regular LINQ, but it also has its limitations. For more information, please refer to [Difference and Limitation](#difference-and-limitation). When you are not familiar with it, we recommend that you use `DropInGenerateTypes.Collection` instead of `DropInGenerateTypes.Everything`.</div>
<div class="line"> </div>
<div class="line">Other options for `ZLinqDropInAttribute` include `GenerateAsPublic`, `ConditionalCompilationSymbols`, and `DisableEmitSource`.</div>
</div><!-- fragment --><p> csharp [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)] public sealed class ZLinqDropInAttribute : Attribute { /// public string GenerateNamespace { get; }</p>
<p>///</p>
<p>/// Gets the types of collections for which LINQ implementations should be generated. /// public DropInGenerateTypes DropInGenerateTypes { get; }</p>
<p>///</p>
<p>/// Gets whether the generated LINQ implementations should be public. /// When true, the implementations will be generated with public visibility. /// When false (default), the implementations will be generated with internal visibility. /// public bool GenerateAsPublic { get; set; }</p>
<p>///</p>
<p>/// Gets or sets the conditional compilation symbols to wrap the generated code with #if directives. /// If specified, the generated code will be wrapped in #if/#endif directives using these symbols. /// public string? ConditionalCompilationSymbols { get; set; }</p>
<p>///</p>
<p>/// Gets or sets whether to disable source generation in emitted code. /// When true, the source code comments will not be included in the generated code. /// When false (default), source code comments will be included in the generated code. /// public bool DisableEmitSource { get; set; }</p>
<p>///</p>
<p>/// Initializes a new instance of the ZLinqDropInAttribute class. /// /// </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">generateNamespace</td><td>The namespace where the generated LINQ implementations will be placed. If empty, place to global.</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">dropInGenerateTypes</td><td>The types of collections for which LINQ implementations should be generated.</td></tr>
  </table>
  </dd>
</dl>
<p>public ZLinqDropInAttribute(string generateNamespace, DropInGenerateTypes dropInGenerateTypes) { GenerateNamespace = generateNamespace; DropInGenerateTypes = dropInGenerateTypes; } } </p><div class="fragment"><div class="line">To support DropIn types other than `DropInGenerateTypes`, you can use `ZLinqDropInExternalExtensionAttribute`. This attribute allows you to generate DropIn for any type by specifying its fully qualified name. For example, to add support for `IReadOnlyCollection&lt;T&gt;` and `IReadOnlyList&lt;T&gt;`, write:</div>
</div><!-- fragment --><p> csharp // T must be written as <code>1 (metadata-name). For nested types, connect with + [assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Generic.IReadOnlyCollection&lt;/tt&gt;1")] [assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Generic.IReadOnlyList`1")] </p><div class="fragment"><div class="line">For types that support `IValueEnumerator&lt;T&gt;` through `AsValueEnumerable()`, specify the ValueEnumerator type name as the second argument. For example, with `ImmutableArray&lt;T&gt;`:</div>
</div><!-- fragment --><p> csharp [assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Immutable.ImmutableArray`1", "ZLinq.Linq.FromImmutableArray`1")] </p><div class="fragment"><div class="line">This allows all operators to be processed by ZLinq using an optimized type.</div>
<div class="line"> </div>
<div class="line">If you want to make your custom collection types DropIn compatible, you can embed them in your assembly using `[ZLinqDropInExtension]`.</div>
</div><!-- fragment --><p> csharp [ZLinqDropInExtension] public class AddOnlyIntList : IEnumerable&lt;int&gt; { List&lt;int&gt; list = new List&lt;int&gt;();</code></p>
<p><code> public void Add(int x) =&gt; list.Add(x);</code></p>
<p><code> public IEnumerator&lt;int&gt; GetEnumerator() =&gt; list.GetEnumerator(); IEnumerator IEnumerable.GetEnumerator() =&gt; list.GetEnumerator(); } </p><div class="fragment"><div class="line">This generates a `public static partial class AddOnlyIntListZLinqDropInExtensions` in the same namespace, overriding all LINQ operators with ZLinq. This works with generic types as well:</div>
</div><!-- fragment --><p> csharp [ZLinqDropInExtension] public class AddOnlyList&lt;T&gt; : IEnumerable&lt;T&gt; </p><div class="fragment"><div class="line">While `[ZLinqDropInExtension]` works with classes implementing `IEnumerable&lt;T&gt;`, implementing `IValueEnumerable&lt;TEnumerator, T&gt;` provides zero-allocation optimization for ZLinq:</div>
</div><!-- fragment --><p> csharp [ZLinqDropInExtension] public class AddOnlyIntList2 : IValueEnumerable&lt;AddOnlyIntList2.Enumerator, int&gt; { List&lt;int&gt; list = new List&lt;int&gt;();</code></p>
<p><code> public void Add(int x) =&gt; list.Add(x);</code></p>
<p><code> public ValueEnumerable&lt;FromValueEnumerable&lt;Enumerator, int&gt;, int&gt; AsValueEnumerable() { // you need to write new(new(new())) magic. return new(new(new(list))); }</code></p>
<p><code> // <code>public</code> struct enumerator public struct Enumerator(List&lt;int&gt; source) : IValueEnumerator&lt;int&gt; { int index;</code></p>
<p><code> public bool TryGetNonEnumeratedCount(out int count) { count = source.Count; return true; }</code></p>
<p><code> public bool TryGetSpan(out ReadOnlySpan&lt;int&gt; span) { span = CollectionsMarshal.AsSpan(source); return true; }</code></p>
<p><code> public bool TryCopyTo(scoped Span&lt;int&gt; destination, Index offset) { // Optional path: if you can not write this, always return false is ok. ReadOnlySpan&lt;int&gt; span = CollectionsMarshal.AsSpan(source); if (ZLinq.Internal.EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice)) { slice.CopyTo(destination); return true;</code></p>
<p><code> } return false; }</code></p>
<p><code> public bool TryGetNext(out int current) { if (index &lt; source.Count) { current = source[index]; index++; return true; }</code></p>
<p><code> current = default; return false; }</code></p>
<p><code> public void Dispose() { } } } </p><div class="fragment"><div class="line">In this case, implementing `IEnumerable&lt;T&gt;` is not necessary. If a collection implements both `IEnumerable&lt;T&gt;` and `IValueEnumerable&lt;TEnumerator, T&gt;`, the latter takes precedence.</div>
<div class="line"> </div>
<div class="line">LINQ to Tree</div>
<div class="line">---</div>
<div class="line">LINQ to XML introduced the concept of querying around axes to C#. Even if you don&#39;t use XML, similar APIs are incorporated into Roslyn and effectively used for exploring SyntaxTrees. ZLinq extends this concept to make it applicable to anything that can be considered a Tree, allowing `Ancestors`, `Children`, `Descendants`, `BeforeSelf`, and `AfterSelf` to be applied.</div>
<div class="line"> </div>
<div class="line">![](img/axis.jpg)</div>
<div class="line"> </div>
<div class="line">Specifically, by defining a struct that implements the following interface, it becomes iterable:</div>
</div><!-- fragment --><p> csharp public interface ITraverser&lt;TTraverser, T&gt; : IDisposable where TTraverser : struct, ITraverser&lt;TTraverser, T&gt; // self { T Origin { get; } TTraverser ConvertToTraverser(T next); // for Descendants bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants bool TryGetChildCount(out int count); // optional: optimize use for Children bool TryGetParent(out T parent); // for Ancestors bool TryGetNextChild(out T child); // for Children | Descendants bool TryGetNextSibling(out T next); // for AfterSelf bool TryGetPreviousSibling(out T previous); // BeforeSelf } </p><div class="fragment"><div class="line">Standard packages are available for FileSystemInfo and JsonNode. For Unity, it&#39;s applicable to GameObject and Transform.</div>
<div class="line"> </div>
<div class="line">### FileSystem</div>
</div><!-- fragment --><p> bash dotnet add package ZLinq.FileSystem </p><div class="fragment"></div><!-- fragment --><p> csharp using ZLinq;</code></p>
<p><code>var root = new DirectoryInfo("C:\\Program Files (x86)\\Steam");</code></p>
<p><code>// FileSystemInfo(FileInfo/DirectoryInfo) can call <code>Ancestors</code>, <code>Children</code>, <code>Descendants</code>, <code>BeforeSelf</code>, <code>AfterSelf</code> var allDlls = root .Descendants() .OfType&lt;FileInfo&gt;() .Where(x =&gt; x.Extension == ".dll");</code></p>
<p><code>var grouped = allDlls .GroupBy(x =&gt; x.Name) .Select(x =&gt; new { FileName = x.Key, Count = x.Count() }) .OrderByDescending(x =&gt; x.Count);</code></p>
<p><code>foreach (var item in grouped) { Console.WriteLine(item); } </p><div class="fragment"><div class="line">### JSON(System.Text.Json)</div>
</div><!-- fragment --><p> bash dotnet add package ZLinq.Json </p><div class="fragment"></div><!-- fragment --><p> csharp using ZLinq;</code></p>
<p><code>// System.Text.Json's JsonNode is the target of LINQ to JSON(not JsonDocument/JsonElement). var json = JsonNode.Parse("""
{
    "nesting": {
      "level1": {
        "description": "First level of nesting",
        "value": 100,
        "level2": {
          "description": "Second level of nesting",
          "flags": [true, false, true],
          "level3": {
            "description": "Third level of nesting",
            "coordinates": {
              "x": 10.5,
              "y": 20.75,
              "z": -5.0
            },
            "level4": {
              "description": "Fourth level of nesting",
              "metadata": {
                "created": "2025-02-15T14:30:00Z",
                "modified": null,
                "version": 2.1
              },
              "level5": {
                "description": "Fifth level of nesting",
                "settings": {
                  "enabled": true,
                  "threshold": 0.85,
                  "options": ["fast", "accurate", "balanced"],
                  "config": {
                    "timeout": 30000,
                    "retries": 3,
                    "deepSetting": {
                      "algorithm": "advanced",
                      "parameters": [1, 1, 2, 3, 5, 8, 13]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
}
""");</code></p>
<p><code>// JsonNode var origin = json!["nesting"]!["level1"]!["level2"]!;</code></p>
<p><code>// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self. foreach (var item in origin.Descendants().Select(x =&gt; x.Node).OfType&lt;JsonArray&gt;()) { // [true, false, true], ["fast", "accurate", "balanced"], [1, 1, 2, 3, 5, 8, 13] Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web)); } </p><div class="fragment"><div class="line">### GameObject/Transform(Unity)</div>
<div class="line"> </div>
<div class="line">see: [unity](#unity) section.</div>
<div class="line"> </div>
<div class="line">LINQ to SIMD</div>
<div class="line">---</div>
<div class="line">In .NET 8 and above, there are operators that apply SIMD when `ValueEnumerable&lt;T&gt;.TryGetSpan` returns true. The scope of application is wider than in regular System.Linq.</div>
<div class="line"> </div>
<div class="line">* **Range** to ToArray/ToList/CopyTo/etc...</div>
<div class="line">* **Repeat** for `unmanaged struct` and `size is power of 2` to ToArray/ToList/CopyTo/etc...</div>
<div class="line">* **Sum** for `sbyte`, `short`, `int`, `long`, `byte`, `ushort`, `uint`, `ulong`, `double`</div>
<div class="line">* **SumUnchecked** for `sbyte`, `short`, `int`, `long`, `byte`, `ushort`, `uint`, `ulong`, `double`</div>
<div class="line">* **Average** for `sbyte`, `short`, `int`, `long`, `byte`, `ushort`, `uint`, `ulong`, `double`</div>
<div class="line">* **Max** for `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `nint`, `nuint`, `Int128`, `UInt128`</div>
<div class="line">* **Min** for `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `nint`, `nuint`, `Int128`, `UInt128`</div>
<div class="line">* **Contains** for `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `bool`, `char`, `nint`, `nuint`</div>
<div class="line">* **SequenceEqual** for `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `bool`, `char`, `nint`, `nuint`</div>
<div class="line"> </div>
<div class="line">`Sum` performs calculations as checked, but if you don&#39;t need to worry about overflow, using `SumUnchecked` is faster.</div>
<div class="line"> </div>
<div class="line">| Method            | N     | Mean          | Allocated |</div>
<div class="line">|------------------ |------ |--------------:|----------:|</div>
<div class="line">| ForLoop           | 16384 | 25,198.556 ns |         - |</div>
<div class="line">| SystemLinqSum     | 16384 |  1,402.259 ns |         - |</div>
<div class="line">| ZLinqSum          | 16384 |  1,351.449 ns |         - |</div>
<div class="line">| ZLinqSumUnchecked | 16384 |    721.832 ns |         - |</div>
<div class="line"> </div>
<div class="line">By using `ZLinq.Simd` in your using statements, you can call `.AsVectorizable()` on `T[]` or `Span&lt;T&gt;` or `ReadOnlySpan&lt;T&gt;`, which allows you to use `Sum`, `SumUnchecked`, `Average`, `Max`, `Min`, `Contains`, and `SequenceEqual`. This explicitly indicates execution with SIMD regardless of the LINQ chain state (though type checking is ambiguous so processing might occur in a normal loop, and if `Vector.IsHardwareAccelerated &amp;&amp; Vector&lt;T&gt;.IsSupported` is false, normal loop processing will be used).</div>
<div class="line"> </div>
<div class="line">From `int[]` or `Span&lt;int&gt;`, you can call `VectorizedFillRange`. This is equivalent to `ValueEunmerable.Range().CopyTo()` and allows you to quickly generate sequential numbers through SIMD processing.</div>
<div class="line"> </div>
<div class="line">| Method | Mean       | Allocated |</div>
<div class="line">|------- |-----------:|----------:|</div>
<div class="line">| Range  |   540.0 ns |         - |</div>
<div class="line">| For    | 6,228.9 ns |         - |</div>
<div class="line"> </div>
<div class="line">### `VectorizedUpdate`</div>
<div class="line"> </div>
<div class="line">In ZLinq, you can perform relatively flexible vectorized loop processing using `Func`. With `T[]` and `Span&lt;T&gt;`, you can use the `VectorizedUpdate` method. By writing two lambda expressions - `Func&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; vectorFunc` for vector operations and `Func&lt;T, T&gt; func` for handling remainder elements - you can perform loop update processing at SIMD width.</div>
</div><!-- fragment --><p> csharp using ZLinq.Simd; // needs using</code></p>
<p><code>int[] source = Enumerable.Range(0, 10000).ToArray();</code></p>
<p><code>[Benchmark] public void For() { for (int i = 0; i &lt; source.Length; i++) { source[i] = source[i] * 10; } }</code></p>
<p><code>[Benchmark] public void VectorizedUpdate() { // arg1: Vector&lt;int&gt; =&gt; Vector&lt;int&gt; // arg2: int =&gt; int source.VectorizedUpdate(static x =&gt; x * 10, static x =&gt; x * 10); } </p><div class="fragment"><div class="line">| Method           | N     | Mean       | Error    | StdDev  | Allocated |</div>
<div class="line">|----------------- |------ |-----------:|---------:|--------:|----------:|</div>
<div class="line">| For              | 10000 | 4,560.5 ns | 67.24 ns | 3.69 ns |         - |</div>
<div class="line">| VectorizedUpdate | 10000 |   558.9 ns |  6.42 ns | 0.35 ns |         - |</div>
<div class="line"> </div>
<div class="line">There is delegate overhead when compared to writing everything inline, but processing can be faster than using for-loops. However, this varies case by case, so please take measurements in advance based on your data volume and method content. Of course, if you&#39;re seeking the best possible performance, you should write code inline.</div>
<div class="line"> </div>
<div class="line">### Vectorizable Methods</div>
<div class="line"> </div>
<div class="line">You can convert from `T[]` or `Span&lt;T&gt;` or `ReadOnlySpan&lt;T&gt;` to `Vectorizable&lt;T&gt;` using `AsVectorizable()`, which allows you to use `Aggregate`, `All`, `Any`, `Count`, `Select`, and `Zip` methods that accept a `Func` as an argument.</div>
<div class="line"> </div>
<div class="line">* `Aggregate`</div>
</div><!-- fragment --><p> csharp source.AsVectorizable().Aggregate((x, y) =&gt; Vector.Min(x, y), (x, y) =&gt; Math.Min(x, y)) </p><div class="fragment"><div class="line">* `All`</div>
</div><!-- fragment --><p> csharp source.AsVectorizable().All(x =&gt; Vector.GreaterThanAll(x, new(5000)), x =&gt; x &gt; 5000); </p><div class="fragment"><div class="line">* `Any`</div>
</div><!-- fragment --><p> csharp source.AsVectorizable().Any(x =&gt; Vector.LessThanAll(x, new(5000)), x =&gt; x &lt; 5000); </p><div class="fragment"><div class="line">* `Count`</div>
</div><!-- fragment --><p> csharp source.AsVectorizable().Count(x =&gt; Vector.GreaterThan(x, new(5000)), x =&gt; x &gt; 5000); </p><div class="fragment"><div class="line">| Method            | Mean        | Error    | StdDev  | Allocated |</div>
<div class="line">|------------------ |------------:|---------:|--------:|----------:|</div>
<div class="line">| VectorizableCount |  1,048.4 ns | 39.39 ns | 2.16 ns |         - |</div>
<div class="line">| LinqCount         | 10,909.3 ns | 54.79 ns | 3.00 ns |         - |</div>
<div class="line"> </div>
<div class="line">* `Select` -&gt; `ToArray` or `CopyTo`</div>
</div><!-- fragment --><p> csharp source.AsVectorizable().Select(x =&gt; x * 3, x =&gt; x * 3).ToArray(); source.AsVectorizable().Select(x =&gt; x * 3, x =&gt; x * 3).CopyTo(destination); </p><div class="fragment"><div class="line">* `Zip` -&gt; `ToArray` or `CopyTo`</div>
</div><!-- fragment --><p> csharp // Zip2 array1.AsVectorizable().Zip(array2, (x, y) =&gt; x + y, (x, y) =&gt; x + y).CopyTo(destination); array1.AsVectorizable().Zip(array2, (x, y) =&gt; x + y, (x, y) =&gt; x + y).ToArray();</code></p>
<p><code>// Zip3 array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&gt; x + y + z, (x, y, z) =&gt; x + y + z).CopyTo(destination); array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&gt; x + y + z, (x, y, z) =&gt; x + y + z).ToArray(); </p><div class="fragment"><div class="line">| Method                      | Mean      |</div>
<div class="line">|---------------------------- |----------:|</div>
<div class="line">| ZLinqVectorizableZipCopyTo  |  24.17 μs |</div>
<div class="line">| ZLinqVectorizableZip3CopyTo |  29.26 μs |</div>
<div class="line">| ZLinqZipCopyTo              | 329.43 μs |</div>
<div class="line">| ZLinqZip3CopyTo             | 584.69 μs |</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Unity</div>
<div class="line">---</div>
<div class="line">There are two installation steps required to use it in Unity.</div>
<div class="line"> </div>
<div class="line">1. Install `ZLinq` from NuGet using [NuGetForUnity](https://github.com/GlitchEnzo/NuGetForUnity)  </div>
<div class="line">Open Window from NuGet -&gt; Manage NuGet Packages, Search &quot;ZLinq&quot; and Press Install. </div>
<div class="line"> </div>
<div class="line">2. Install the `ZLinq.Unity` package by referencing the git URL  </div>
</div><!-- fragment --><p> bash <a href="https://github.com/Cysharp/ZLinq.git?path=src/ZLinq.Unity/Assets/ZLinq.Unity">https://github.com/Cysharp/ZLinq.git?path=src/ZLinq.Unity/Assets/ZLinq.Unity</a> </p><div class="fragment"><div class="line">With the help of the Unity package, in addition to the standard ZLinq, LINQ to GameObject functionality becomes available for exploring GameObject/Transform.</div>
<div class="line"> </div>
<div class="line">![](img/axis.jpg)</div>
</div><!-- fragment --><p> csharp using ZLinq;</code></p>
<p><code>public class SampleScript : MonoBehaviour { public Transform Origin;</code></p>
<p><code> void Start() { Debug.Log("Ancestors--------------"); // Container, Root foreach (var item in Origin.Ancestors()) Debug.Log(item.name);</code></p>
<p><code> Debug.Log("Children--------------"); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B foreach (var item in Origin.Children()) Debug.Log(item.name);</code></p>
<p><code> Debug.Log("Descendants--------------"); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B foreach (var item in Origin.Descendants()) Debug.Log(item.name);</code></p>
<p><code> Debug.Log("BeforeSelf--------------"); // C1, C2 foreach (var item in Origin.BeforeSelf()) Debug.Log(item.name);</code></p>
<p><code> Debug.Log("AfterSelf--------------"); // C3, C4 foreach (var item in Origin.AfterSelf()) Debug.Log(item.name); } } </p><div class="fragment"><div class="line">You can chain query(LINQ to Objects). Also, you can filter by component using the `OfComponent&lt;T&gt;` helper.</div>
</div><!-- fragment --><p> csharp // all filtered(tag == "foobar") objects var foobars = root.Descendants().Where(x =&gt; x.tag == "foobar");</code></p>
<p><code>// get FooScript under self childer objects and self var fooScripts = root.ChildrenAndSelf().OfComponent&lt;FooScript&gt;(); </p><div class="fragment"><div class="line">NOTE: In Unity, since .NET Standard 2.1 is referenced, SIMD is not utilized.</div>
<div class="line"> </div>
<div class="line">In .NET 9, `ValueEnumerable` is a `ref struct`, so it cannot be converted to `IEnumerable&lt;T&gt;`. However, in Unity it&#39;s a regular `struct`, making it possible to convert to `IEnumerable&lt;T&gt;`. You can improve interoperability by preparing an extension method like this:</div>
</div><!-- fragment --><p> csharp public static class ZLinqExtensions { public static IEnumerable&lt;T&gt; AsEnumerable&lt;TEnumerator, T&gt;(this ValueEnumerable&lt;TEnumerator, T&gt; valueEnumerable) where TEnumerator : struct, IValueEnumerator&lt;T&gt; { using (var e = valueEnumerable.Enumerator) { while (e.TryGetNext(out var current)) { yield return current; } } } } </p><div class="fragment"><div class="line">In Unity, you can convert `NativeArray`, `NativeSlice` using `AsEnumerable()` to write queries with ZLinq. If Unity Collections(`com.unity.collections`) package version is `2.1.1` or above,  `NativeQueue`, `NativeHashSet`, `NativeText`, `FixedList32Bytes`, `FixedList64Bytes`, `FixedList128Bytes`, `FixedList512Bytes`, `FixedList4096Bytes`, `FixedString32Bytes`, `FixedString64Bytes`, `FixedString128Bytes`, `FixedString512Bytes`, and `FixedString4096Bytes` support `AsValueEnumerable()`.</div>
<div class="line"> </div>
<div class="line">You can also use drop-in replacement. Add `ZLinq.DropInGenerator` from NuGetForUnity. If you want to use DropInGenerator, the minimum supported Unity version will be `2022.3.12f1`, as it is necessary to support C# Incremental Source Generator(Compiler Version, 4.3.0).</div>
<div class="line"> </div>
<div class="line">Assembly attributes need to be set for each asmdef. For example, place a `.cs` file like the following in each asmdef. The DropInGenerator is defined in the assembly attributes.</div>
</div><!-- fragment --><p> csharp // AssemblyAttributes.cs using ZLinq; [assembly: ZLinqDropIn("MyApp", DropInGenerateTypes.Array | DropInGenerateTypes.List)] </p><div class="fragment"><div class="line">For more details about DropInGenerator, please refer to the [Drop-in replacement](#drop-in-replacement) section.</div>
<div class="line"> </div>
<div class="line">To support Native Collections in addition to regular DropIn types, you can use `ZLinqDropInExternalExtension` as follows:</div>
</div><!-- fragment --><p> csharp [assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeArray`1", "ZLinq.Linq.FromNativeArray`1")] [assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeArray`1+ReadOnly", "ZLinq.Linq.FromNativeArray`1")] [assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeSlice`1", "ZLinq.Linq.FromNativeSlice`1")] [assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeList`1", "ZLinq.Linq.FromNativeList`1")] </p><div class="fragment"><div class="line">This is not just about Unity, but using `AsValueEnumerable()` even if only for foreach on `IEnumerable&lt;T&gt;` can sometimes reduce allocations. If the actual implementation of `IEnumerable&lt;T&gt;` is a `T[]` or `List&lt;T&gt;`, ZLinq will process it appropriately without allocations.</div>
<div class="line"> </div>
<div class="line">![](img/unityforeach.png)</div>
</div><!-- fragment --><p> csharp void IterateNormal(IEnumerable&lt;int&gt; source) { // Normally there's an allocation when getting IEnumerator&lt;T&gt;. foreach (var item in source) {</code></p>
<p><code> } }</code></p>
<p><code>void IterateZLinq(IEnumerable&lt;int&gt; source) { // Adding AsValueEnumerable results in 0 allocation. // However, zero alloc only works when the actual implementation of IEnumerable&lt;T&gt; is an array [] or List&lt;T&gt; foreach (var item in source.AsValueEnumerable()) {</code></p>
<p><code> } } </p><div class="fragment"><div class="line">Godot</div>
<div class="line">---</div>
<div class="line">The minimum supported Godot version will be `4.0.0`.</div>
<div class="line">You can install ZLinq.Godot package via NuGet.</div>
</div><!-- fragment --><p> bash dotnet add package ZLinq.Godot </p><div class="fragment"><div class="line">In addition to the standard ZLinq, LINQ to Node functionality is available.</div>
<div class="line"> </div>
<div class="line">![](img/godot.jpg)</div>
</div><!-- fragment --><p> csharp using Godot; using ZLinq;</code></p>
<p><code>public partial class SampleScript : Node2D { public override void _Ready() { var origin = GetNode&lt;Node2D&gt;("Container/Origin");</code></p>
<p><code> GD.Print("Ancestors--------------"); // Container, Root, root (Root Window) foreach (var item in origin.Ancestors()) GD.Print(item.Name);</code></p>
<p><code> GD.Print("Children--------------"); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B foreach (var item in origin.Children()) GD.Print(item.Name);</code></p>
<p><code> GD.Print("Descendants--------------"); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B foreach (var item in origin.Descendants()) GD.Print(item.Name);</code></p>
<p><code> GD.Print("BeforeSelf--------------"); // C1, C2 foreach (var item in origin.BeforeSelf()) GD.Print(item.Name);</code></p>
<p><code> GD.Print("AfterSelf--------------"); // C3, C4 foreach (var item in origin.AfterSelf()) GD.Print(item.Name); } }</code></p>
<p><code></p><div class="fragment"><div class="line">You can chain query(LINQ to Objects). Also, you can filter by node type using the `OfType()`.</div>
</div><!-- fragment --><p> csharp // get ancestors under a Window var ancestors = root.Ancestors().TakeWhile(x =&gt; x is not Window); // get FooScript under self childer objects and self var fooScripts = root.ChildrenAndSelf().OfType&lt;FooScript&gt;(); </p><div class="fragment"><div class="line">Custom Extensions</div>
<div class="line">---</div>
<div class="line"> </div>
<div class="line">Implementing extension methods for `IEnumerable&lt;T&gt;` is common. There are two types of operators: consuming operators like `Count` and `Sum`, and chainable operators like `Select` and `Where`. This section explains how to implement them.</div>
<div class="line"> </div>
<div class="line">#### Consume Operator</div>
<div class="line"> </div>
<div class="line">The method signature is slightly more complex compared to `IEnumerable&lt;T&gt;`, requiring constraints on `TEnumerator`. For .NET 9 or later, `allows ref struct` is also needed.</div>
</div><!-- fragment --><p> csharp public static class MyExtensions { public static void Consume&lt;TEnumerator, TSource&gt;(this ValueEnumerable&lt;TEnumerator, TSource&gt; source) where TEnumerator : struct, IValueEnumerator&lt;TSource&gt; #if NET9_0_OR_GREATER , allows ref struct #endif { using var e = source.Enumerator; // using Enumerator</code></p>
<p><code> while (e.TryGetNext(out var current)) // MoveNext + Current { } } } </p><div class="fragment"><div class="line">Instead of `GetEnumerator()`, use `Enumerator`, and instead of `MoveNext + Current`, use `TryGetNext(out)` to consume the iterator. The Enumerator must be used with `using`.</div>
<div class="line"> </div>
<div class="line">Consumers can call the Enumerator&#39;s optimization methods: `TryGetNonEnumeratedCount`, `TryGetSpan`, and `TryCopyTo`. For example, getting a Span like this is faster than normal iteration with TryGetNext:</div>
</div><!-- fragment --><p> csharp public static class MyExtensions { public static void ForEach&lt;TEnumerator, TSource&gt;(this ValueEnumerable&lt;TEnumerator, TSource&gt; source, Action&lt;TSource&gt; action) where TEnumerator : struct, IValueEnumerator&lt;TSource&gt; #if NET9_0_OR_GREATER , allows ref struct #endif { using var e = source.Enumerator;</code></p>
<p><code> if (e.TryGetSpan(out var span)) { // faster iteration foreach (var item in span) { action(item); } } else { while (e.TryGetNext(out var item)) { action(item); } } }</code></p>
<p><code> public static ImmutableArray&lt;T&gt; ToImmutableArray&lt;TEnumerator, T&gt;(this ValueEnumerable&lt;TEnumerator, T&gt; source) where TEnumerator : struct, IValueEnumerator&lt;T&gt; #if NET9_0_OR_GREATER , allows ref struct #endif { using var e = source.Enumerator;</code></p>
<p><code> if (e.TryGetSpan(out var span)) { return ImmutableArray.Create(span); } else { // set capacity if can var builder = e.TryGetNonEnumeratedCount(out var count) ? ImmutableArray.CreateBuilder&lt;T&gt;(count) : ImmutableArray.CreateBuilder&lt;T&gt;();</code></p>
<p><code> while (e.TryGetNext(out var current)) { builder.Add(current); }</code></p>
<p><code> return builder.ToImmutable(); } } } </p><div class="fragment"><div class="line">Since the enumerator&#39;s state changes, you cannot call other methods after calling `TryGetNext`. Also, you cannot call `TryGetNext` after `TryCopyTo` or `TryGetSpan` returns `true`.</div>
<div class="line"> </div>
<div class="line">#### Custom Operator</div>
<div class="line"> </div>
<div class="line">Unlike `IEnumerable&lt;T&gt;`, you can&#39;t use `yield return`, so everything must be implemented by hand, making it more difficult than Consume operators. A simple `Select` implementation looks like this. For .NET 9 or later, `IValueEnumerator&lt;T&gt;` must be implemented as a `ref struct`. Also, the accessibility must be `public` or `internal`.</div>
</div><!-- fragment --><p> csharp public static class MyExtensions { public static ValueEnumerable&lt;SimpleSelect&lt;TEnumerator, TSource, TResult&gt;, TResult&gt; SimpleSelect&lt;TEnumerator, TSource, TResult&gt;(this ValueEnumerable&lt;TEnumerator, TSource&gt; source, Func&lt;TSource, TResult&gt; selector) where TEnumerator : struct, IValueEnumerator&lt;TSource&gt; #if NET9_0_OR_GREATER , allows ref struct #endif { // ValueEnumerable is only a wrapper so unwrapping to enumerator immediately is ok. // <code>new(new())</code> is <code>new ValueEnumerable(new SimpleSelect())</code>, wrap enumerator to ValueEnumerable. return new(new(source.Enumerator, selector)); } }</code></p>
<p><code>#if NET9_0_OR_GREATER public ref struct #else public struct #endif SimpleSelect&lt;TEnumerator, TSource, TResult&gt;(TEnumerator source, Func&lt;TSource, TResult&gt; selector) : IValueEnumerator&lt;TResult&gt; where TEnumerator : struct, IValueEnumerator&lt;TSource&gt; #if NET9_0_OR_GREATER , allows ref struct #endif { TEnumerator source = source; // need to store source enumerator in field explicitly (ref struct limitation)</code></p>
<p><code> public bool TryGetNonEnumeratedCount(out int count) { // If source count is not changed, return count. // Select count is same as source. return source.TryGetNonEnumeratedCount(out count); }</code></p>
<p><code> public bool TryGetSpan(out ReadOnlySpan&lt;TResult&gt; span) { // For example, Take or Skip could return a Slice span = default; return false; }</code></p>
<p><code> public bool TryCopyTo(scoped Span&lt;TResult&gt; destination, Index offset) { // TryCopyTo implementation needs to consider Index calculations, so it's quite complex. // Also, destination can be smaller than the source size. // Helper methods for calculations are available in ZLinq.Internal.EnumeratorHelper, // such as TryGetSliceRange, TryGetSlice, TryGetSliceRange, TryConsumeGetAt, etc. return false; }</code></p>
<p><code> // This is the main body of the normal processing public bool TryGetNext(out TResult current) { while (source.TryGetNext(out var value)) { current = selector(value); return true; }</code></p>
<p><code> current = default!; return false; }</code></p>
<p><code> public void Dispose() { // Always dispose the source source.Dispose(); } } ```</code></p>
<p><code>For <code>TryGetNonEnumeratedCount</code>, <code>TryGetSpan</code>, and <code>TryCopyTo</code>, it's fine to return <code>false</code> if implementation is difficult. If state is needed (for example, Take needs to keep track of the number of calls), place it in a field, but note that you should not initialize reference types or structs containing reference types in the constructor. This is because in method chains, Enumerators are passed by copy, so reference types would share references. If you need to hold reference types, they must be initialized when <code>TryGetNext</code> is first called.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md4"></a>
<code>Acknowledgement</code></h1>
<p><code></code></p>
<p><code>Since the preview version release, we have received multiple ideas for fundamental interface revisions leading to performance improvements from <a href="https://github.com/Akeit0">@Akeit0</a>, and test and benchmark infrastructure from <a href="https://github.com/filzrev">@filzrev</a>. We are grateful for their many contributions.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md5"></a>
<code>License</code></h1>
<p><code></code></p>
<p><code>This library is under MIT License. </code></p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e5fbe6d2783ccd4c93c7856d92d7be6e.html">GitHub</a></li><li class="navelem"><a class="el" href="dir_f15e61a9082ae4fe2b555218d6ae77ae.html">LodgingSimulator</a></li><li class="navelem"><a class="el" href="dir_4e8ddfaea497fe5c92f0f4e55edefc7b.html">Assets</a></li><li class="navelem"><a class="el" href="dir_0ea053e874feef6b37533f3b4cb53b6f.html">Packages</a></li><li class="navelem"><a class="el" href="dir_3434b0f81afe74e216ba227be80e6f9e.html">ZLinq.1.4.0</a></li>
    <li class="footer">다음에 의해 생성됨 :  <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
